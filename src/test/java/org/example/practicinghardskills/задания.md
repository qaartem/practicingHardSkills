**ArrayList (хотя бы 2 любые задачи)**

Задача 1:
Создайте ArrayList из 5 чисел. Добавьте ещё одно число в конец. Выведите весь список.
Подсказка:
Используй Arrays.asList() для создания списка из 5 чисел.
Чтобы добавить ещё одно число, оберни в new ArrayList<>(...), потому что список из Arrays.asList() фиксирован по размеру.
Для добавления — метод add(), для вывода — System.out.println(list) или цикл for.

Задача 2:
Напишите программу, которая выводит все чётные числа из ArrayList.
Подсказка:
Создай ArrayList<Integer> и заполни числами.
Используй цикл for-each для прохода по списку.
Внутри цикла используй условие if (number % 2 == 0), чтобы проверить чётность.
Выводи подходящие числа с помощью System.out.println().

Задача 3:
Создайте ArrayList из строк. Найдите в нём самую длинную строку и выведите её.
Подсказка:
Объяви переменную String longest = "".
Пройдись по списку с помощью цикла for-each.
Внутри цикла сравни длину текущей строки с longest.length() и обнови longest, если найдена строка длиннее.
После цикла выведи longest.

Задача 4:
Создайте ArrayList из целых чисел. Напишите программу, которая вычисляет и выводит сумму всех чисел в списке.
Подсказка:
Объяви int sum = 0.
Используй цикл for-each для перебора всех элементов списка.
На каждой итерации прибавляй текущее число к переменной sum.
После цикла выведи sum через System.out.println().

Задача 5:
Создайте ArrayList из целых чисел. Напишите программу, которая находит и выводит максимальное число из списка.
Подсказка:
Можно использовать Collections.max(list).
Или вручную:
Объяви переменную int max = list.get(0) (предположим, что список не пуст).
Пройдись по списку в цикле.
Если текущее число больше max, обнови значение переменной.
После цикла выведи max.

**HashMap (хотя бы 2 любые задачи)**

Задача 1:
Создайте HashMap<String, Integer>, добавьте 5 пар (имя – возраст) и выведите все записи.
Подсказка:
Используй HashMap<String, Integer>
Добавь пары с помощью put("Имя", возраст)
Пройдись по паре Map.Entry<String, Integer> с помощью for-each цикла
Используй entry.getKey() и entry.getValue() для вывода каждой записи

Задача 2:
Проверьте, есть ли определённое имя в HashMap.
Подсказка:
Используй метод containsKey("Имя")
Имя можно задать вручную или получить через Scanner
Если имя найдено — выведи возраст или сообщение "Найдено"
Если не найдено — выведи "Не найдено"

Задача 3:
Реализуйте метод, который печатает из HashMap всех пользователей младше 18 лет.
Подсказка:
Создай метод с сигнатурой void printUnderage(Map<String, Integer> map)
Пройдись по элементам с помощью for (Map.Entry<String, Integer> entry : map.entrySet())
Внутри цикла проверь entry.getValue() < 18
Если условие выполняется — выведи имя и возраст

**LinkedHashMap (хотя бы 1 любая задача)**

Задача 1:
Создайте LinkedHashMap и добавьте в него 5 элементов. Выведите их в порядке добавления.
Подсказка:
Используй LinkedHashMap<String, Integer> или другой тип на выбор
Добавляй элементы методом put(key, value)
Используй цикл for (Map.Entry<K, V> entry : map.entrySet())
LinkedHashMap сохраняет порядок добавления — элементы выведутся в том же порядке, в котором были добавлены

Задача 2:
Реализуйте телефонную книгу с LinkedHashMap. Добавьте и найдите контакт.
Подсказка:
Используй LinkedHashMap<String, String> где ключ — имя, значение — номер телефона
Для добавления используй put(name, phone)
Для поиска используй containsKey(name) и get(name)
Имя можно передать в метод или считать с клавиатуры
Если контакт найден — выведи номер телефона, иначе сообщение "Контакт не найден"

Задача 3:
Создайте LinkedHashMap, который хранит историю просмотров пользователя (максимум 10 элементов).
Подсказка:
Используй LinkedHashMap<String, String> где ключ — идентификатор страницы, значение — её название
Если размер мапы 10, а добавляется новый элемент - удаляй первый.
Выводи историю с помощью entrySet(), порядок будет от самого старого к новому

**TreeMap (хотя бы 1 любая задача)**

Задача 1:
Создайте TreeMap и добавьте 5 ключей (имена) и значений (баллы). Выведите отсортированные данные.
Подсказка:
Используй TreeMap<String, Integer>
Добавляй пары с помощью put(name, score)
TreeMap сортирует ключи по алфавиту
Для вывода используй цикл for (Map.Entry<String, Integer> entry : map.entrySet())
Убедись, что имена добавляются в случайном порядке, чтобы увидеть сортировку по ключу

Задача 2:
Найдите минимальный и максимальный ключ в TreeMap.
Подсказка:
После создания и заполнения TreeMap, используй методы:
firstKey() — возвращает минимальный ключ
lastKey() — возвращает максимальный ключ
Выведи оба значения через System.out.println()

PriorityQueue

Задача 1:
Создайте PriorityQueue и добавьте 5 чисел. Выведите их в порядке удаления.
Подсказка:
Используй PriorityQueue<Integer>
Добавляй числа через add() или offer()
Элементы автоматически сортируются по возрастанию при извлечении
Используй poll() в цикле while (!queue.isEmpty()) для поочерёдного извлечения и вывода


ArrayDeque (хотя бы 1 любая задача)

Задача 1:
Создайте ArrayDeque, добавьте 5 элементов и выведите их.
Подсказка:
Используй ArrayDeque<String> (или другой тип по желанию)
Добавляй элементы с помощью add() или addLast()
Для вывода используй for-each цикл или System.out.println(deque)
ArrayDeque сохраняет порядок добавления при обычном использовании

Задача 2:
Используйте ArrayDeque как стек: добавьте элементы и извлеките их в обратном порядке.
Подсказка:
Добавляй элементы с помощью push()
Извлекай с помощью pop() — они будут извлекаться в порядке LIFO (последним добавлен — первым извлечён)
Используй while (!deque.isEmpty()) для последовательного извлечения и вывода

Задача 3:
Используйте ArrayDeque как очередь: добавьте элементы в начало и конец, извлеките из обоих концов.
Подсказка:
Используй addFirst() и addLast() для добавления в начало и конец
Извлекай элементы с помощью removeFirst() и removeLast()
Выводи результат после каждого извлечения, чтобы увидеть порядок
ArrayDeque отлично работает как двусторонняя очередь (deque)

**LinkedList (хотя бы 2 любые задачи)**

Задача 1:
Создайте LinkedList и добавьте в него 5 строк. Выведите все элементы списка.

Задача 2:
Реализуйте очередь задач с LinkedList. Добавьте 3 задачи и обработайте их в порядке поступления.

Задача 3:
Создайте LinkedList, содержащий несколько строк. Напишите программу, которая печатает первый и последний элементы списка.

Задача 4:
Создайте LinkedList из целых чисел. Напишите программу, которая вычисляет сумму элементов списка.

Задача 5:
Используйте ListIterator для прохода по LinkedList в обоих направлениях.


**Задачи на исключения**

1. Обработка проверяемого исключения
   Условие задачи:
   Напишите программу, которая пытается открыть файл с именем "data.txt". Если файл не найден, программа должна обработать исключение и вывести сообщение: "Файл не найден".

2. Обработка непроверяемого исключения
   Условие задачи: Напишите метод, который принимает на вход два числа и выполняет их деление. Обработайте ситуацию, когда второе число равно нулю, чтобы избежать исключения при делении.

3. Создание и использование собственного проверяемого исключения
   Условие задачи: Разработайте метод, который проверяет валидность возраста пользователя. Если возраст меньше 0 или больше 150, метод должен выбрасывать проверяемое исключение.

4. Создание и использование собственного непроверяемого исключения
   Условие задачи: Напишите функцию, которая принимает строку в качестве аргумента и проверяет, является ли строка правильным электронным адресом. Если строка не удовлетворяет критериям, функция должна выбрасывать непроверяемое исключение.

**Задачи на дженерики**

1. Задача на дженерик класс
   Условие задачи: Разработайте дженерик класс Box, который может хранить объекты любого типа. Класс должен иметь методы для установки и получения значения объекта, хранящегося внутри.

2. Задача на дженерик метод
   Условие задачи: Напишите дженерик метод printArray, который принимает массив элементов любого типа и выводит каждый элемент массива на консоль.

3. Задача на дженерик с двумя типами данных
   Условие задачи: Создайте класс Pair, который может хранить два объекта разных типов. Класс должен позволять получать и устанавливать каждый из этих объектов.

**Дополнительные задачи (по желанию):**

4. **Обобщённый класс**
Задача: Создайте класс Storage<T>, который хранит элемент и возвращает его.

5. **Обобщённый метод**
Задача: Реализуйте метод printList(List<T>), который принимает список любого типа и выводит его элементы.

6. **Работа с числами**
Задача: Создайте класс NumberBox<T extends Number>, который хранит только числа и возвращает их сумму.

7. **Ограничение сверху**
Задача: Напишите обобщённый метод, который принимает List<T extends Number> и вычисляет сумму элементов.

8. **Ограничение снизу**
Задача: Реализуйте метод, который принимает List<T super Integer> и добавляет в него несколько чисел.

9. **Обобщённый интерфейс**
Задача: Создайте интерфейс Container<T>, содержащий методы add(T item) и get().

10. **Коллекция с обобщёнными типами**
Задача: Создайте Map<K, V> и реализуйте метод, который принимает обобщённые ключи и значения, а затем выводит их.

**Часть 1: Функциональные интерфейсы и лямбда-выражения**


**1. Создайте свой функциональный интерфейс**
   Задача: Напишите интерфейс MathOperation, который принимает два числа и возвращает результат операции. Реализуйте его с помощью лямбда-выражений: сложение, вычитание, умножение, деление.

**2. Использование анонимного класса**
   Задача: Создайте анонимный класс, реализующий интерфейс Runnable, который выводит сообщение "Hello from anonymous class!".

**3. Лямбда-выражение с Predicate**
   Задача: Напишите лямбду, которая проверяет, является ли число чётным.

**4. Лямбда-выражение с Function**
   Задача: Создайте лямбду, которая принимает строку и возвращает её длину.

**5. Использование Consumer**
   Задача: Напишите лямбду, которая принимает строку и печатает её в консоль.

**Часть 2: Stream API – базовые операции**


**1. Фильтрация строк по длине больше 5**
   Задача: Напишите программу, которая принимает список строк и удаляет из него все строки длиной 5 символов и менее, используя Stream API.

**2. Фильтрация чисел, кратных 5**
   Задача: Напишите программу, которая принимает список чисел и отбирает только те, которые делятся на 5 без остатка, используя Stream API.

**3. Преобразование строк в их длины**
   Задача: Напишите программу, которая принимает список строк и заменяет каждую строку на её длину, используя Stream API.

**4. Создание списка квадратов чисел**
   Задача: Напишите программу, которая принимает список чисел и преобразует его в новый список, где каждое число заменено на его квадрат, используя Stream API.

**5. Удаление дубликатов из списка**
   Задача: Напишите программу, которая принимает список элементов и удаляет из него все дубликаты, используя Stream API.

**Часть 3: Stream API – агрегирующие операции**

**1. Поиск максимального элемента**
   Задача: Напишите программу, которая принимает список чисел и находит в нём самое большое число, используя Stream API.

**2. Поиск минимального элемента**
   Задача: Напишите программу, которая принимает список чисел и находит в нем наименьшее число, используя Stream API.

**3. Сумма всех элементов списка**
   Задача: Напишите программу, которая принимает список чисел и вычисляет их сумму, используя Stream API.

**4. Поиск первого элемента, начинающегося на "Б"**
   Задача: Напишите программу, которая принимает список строк и находит первую строку, начинающуюся на букву "Б", используя Stream API.

**5. Проверка наличия хотя бы одного элемента по условию**
  Задача: Напишите программу, которая проверяет, есть ли хотя бы один элемент в списке, который удовлетворяет заданному условию (например, является чётным числом), используя Stream API.

**Подсказки:**
**1. Поиск максимального элемента:**
   Нужно найти самое большое число в списке. Сначала превращаем список в поток. Затем используем метод max, который сравнивает элементы. Он возвращает Optional, так как список может быть пустым. Чтобы получить само число, нужно вызвать get() или orElse().
   **Методы:**
`   stream()
   max(Comparator.naturalOrder())
   get() или orElse(...)`
**2. Поиск минимального элемента:**
   Нужно найти наименьшее значение в списке чисел. После создания потока применяем метод min, который возвращает Optional. Если список не пуст, можно получить значение через get() или orElse(...).
   **Методы:**
`   stream()
   min(Comparator.naturalOrder())
   get() или orElse(...)`
**3. Сумма всех элементов списка:**
   Чтобы посчитать сумму всех чисел в списке, сначала превращаем его в поток. Затем преобразуем его в числовой поток (целые числа). После этого используем метод sum, который возвращает сумму всех элементов.
   **Методы:**
`   stream()
   mapToInt(n -> n)
   sum()`
**4. Поиск первого элемента, начинающегося на "Б":**
   Нужно найти первую строку, начинающуюся с определённой буквы. Для этого создаём поток, фильтруем элементы по условию (startsWith("Б")), а затем берём первый подходящий с помощью findFirst(). Результат будет в Optional.
   **Методы:**
`   stream()
   filter(s -> s.startsWith("Б"))
   findFirst()`
**5. Проверка наличия хотя бы одного элемента по условию:**
   Нужно проверить, есть ли хотя бы один элемент, удовлетворяющий условию (например, чётное число). После создания потока используем метод anyMatch, который вернёт true, если хотя бы один элемент проходит проверку.
   **Методы:**
`   stream()
   anyMatch(n -> условие)`

**Часть 4: Stream API – группировка и редукция**


**1. Группировка строк по первой букве**
   **Задача:** Напишите программу, которая принимает список строк и группирует их по первой букве, используя Stream API.

**2. Группировка чисел по чётности**
   **Задача:** Напишите программу, которая принимает список чисел и группирует их на чётные и нечётные, используя Stream API.

**3. Поиск среднего значения чисел**
   **Задача:** Напишите программу, которая принимает список чисел и находит их среднее значение, используя Stream API.

**Подсказки:**
**1. Группировка строк по первой букве:**
   Нужно сгруппировать слова по первой букве. Сначала превращаем список строк в поток. Затем используем метод collect, который собирает элементы в коллекцию. С помощью Collectors.groupingBy(...) мы можем указать ключ для группировки — в данном случае, первую букву каждого слова. Это может быть word.charAt(0) или word.substring(0, 1).
   Методы:
`   stream()
   collect(...)
   Collectors.groupingBy(...)
   s -> s.charAt(0) или s -> s.substring(0, 1)`
**2. Группировка чисел по чётности:**
   Нужно разделить числа на две группы: чётные и нечётные. Сначала получаем поток из списка. Затем используем collect с Collectors.groupingBy(...), передавая в качестве ключа булевое выражение n % 2 == 0. В результате получится отображение: true — список чётных чисел, false — нечётных.
   Методы:
   stream()
   collect(...)
   Collectors.groupingBy(...)
   n -> n % 2 == 0
**3. Поиск среднего значения чисел:**
   Чтобы найти среднее значение, преобразуем список в поток. Затем применяем метод collect с Collectors.averagingInt(...). Внутри указываем функцию, возвращающую значение элемента. Если список содержит Integer, то достаточно использовать n -> n.
   Методы:
`   stream()
   collect(...)
   Collectors.averagingInt(n -> n)`